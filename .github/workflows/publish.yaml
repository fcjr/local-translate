# See:
# - <https://github.com/tauri-apps/tauri-action>
# - <https://pytauri.github.io/pytauri/latest/usage/tutorial/build-standalone/>

name: "publish"

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump type"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major

defaults:
  run:
    shell: bash

jobs:
  bump-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Bump release version
        id: version
        run: |
          CURRENT=$(jq -r '.version' src-tauri/tauri.conf.json)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
          case "${{ inputs.bump }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac
          VERSION="${MAJOR}.${MINOR}.${PATCH}"
          jq --arg v "$VERSION" '.version = $v' src-tauri/tauri.conf.json > tmp.json && mv tmp.json src-tauri/tauri.conf.json
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Commit version bump
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add src-tauri/tauri.conf.json
          git commit -m "Bump version to ${{ steps.version.outputs.version }}"
          git push

  publish-tauri:
    needs: bump-version
    permissions:
      contents: write # required for creating github releases
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: "macos-14" # for Arm based macs (M1 and above).
            target: "aarch64-apple-darwin"

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - name: Rust cache
        uses: swatinem/rust-cache@v2

      - name: Install uv
        uses: astral-sh/setup-uv@v6
        with:
          enable-cache: true
          # version-file: "pyproject.toml"

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          # Optional: when there is a `packageManager` field in the `package.json`
          version: "latest"
      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          # Or: `node-version-file: package.json`
          node-version: lts/*
          cache: "pnpm"

      - name: Install project dependencies
        run: |
          pnpm install

      # See:
      # - <https://github.com/astral-sh/python-build-standalone/releases>
      # - <https://raw.githubusercontent.com/astral-sh/python-build-standalone/latest-release/latest-release.json>
      # - <https://gregoryszorc.com/docs/python-build-standalone/main/running.html#obtaining-distributions>
      - name: Download python-build-standalone
        env:
          PYTHON_VERSION: "3.12.12" # must be <3.13 for mlx-audio compatibility
          TAG: "20260211"
          TARGET: ${{ matrix.target }}
        run: |
          url="https://github.com/astral-sh/python-build-standalone/releases/download/${TAG}/cpython-${PYTHON_VERSION}+${TAG}-${TARGET}-install_only_stripped.tar.gz"
          DEST_DIR="src-tauri/pyembed"

          mkdir "$DEST_DIR"
          curl -fL "$url" | tar -xz -C "$DEST_DIR"

          # ref: <https://github.com/pytauri/pytauri/issues/99#issuecomment-2704556726>
          if [[ "${{ runner.os }}" == "macOS" ]]; then
              python_major_minor="${PYTHON_VERSION%.*}"  # "3.12.12" -> "3.12"
              install_name_tool -id "@rpath/libpython${python_major_minor}.dylib" "$DEST_DIR/python/lib/libpython${python_major_minor}.dylib"
          fi

      - name: Install the project into the embedded python environment
        env:
          PYTAURI_STANDALONE: 1 # see your `setup.py`
        run: |
          uv pip install \
              --exact \
              --compile-bytecode \
              --prerelease=allow \
              --python=./src-tauri/pyembed/python/bin/python3 \
              ./src-tauri

      - name: Strip unused packages from embedded Python
        run: |
          PY=./src-tauri/pyembed/python/bin/python3

          # Remove packages not needed at runtime — these are transitive deps
          # of librosa/transformers that our Qwen3-TTS code path never imports
          uv pip uninstall --python="$PY" \
              scipy scikit-learn numba llvmlite joblib \
              pillow pip

          # Remove tkinter/tcl/tk (not needed for headless Python backend)
          rm -rf src-tauri/pyembed/python/lib/libtcl* \
                 src-tauri/pyembed/python/lib/libtk* \
                 src-tauri/pyembed/python/lib/tcl* \
                 src-tauri/pyembed/python/lib/tk* \
                 src-tauri/pyembed/python/lib/python*/lib-dynload/_tkinter*

          # Clean up test dirs and bytecode caches
          find src-tauri/pyembed -type d \( -name "test" -o -name "tests" -o -name "testing" -o -name "__pycache__" \) -exec rm -rf {} +

      # Set build environment variables, see:
      # <https://pytauri.github.io/pytauri/latest/usage/tutorial/build-standalone/#build-and-bundle>

      - name: Codesign embedded Python binaries for notarization
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          CERT_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          echo "::add-mask::$KEYCHAIN_PASSWORD"

          # Set up a temporary keychain with the signing certificate
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$APPLE_CERTIFICATE" | base64 --decode > "$CERT_PATH"
          security import "$CERT_PATH" \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain

          # Sign all Mach-O binaries in the embedded Python distribution —
          # Tauri only signs its own frameworks/sidecars, not bundled resources.
          # Using `file` detection instead of name patterns to catch everything:
          # executables (python3.12), dylibs (libpython, libtcl, libllvmlite, etc.),
          # and extension modules (.so files from numpy, mlx, tokenizers, etc.)
          find src-tauri/pyembed -type f | while read -r file; do
            if file "$file" | grep -q "Mach-O"; then
              codesign --force --options runtime --sign "$APPLE_SIGNING_IDENTITY" --timestamp "$file"
            fi
          done

      - name: Clean up signing keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/signing.keychain-db 2>/dev/null || true
          rm -f $RUNNER_TEMP/certificate.p12

      - name: Set build environment variables
        run: |
          PYO3_PYTHON=$(realpath ./src-tauri/pyembed/python/bin/python3)
          RUSTFLAGS=" \
            -C link-arg=-Wl,-rpath,@executable_path/../Resources/lib \
            -L $(realpath ./src-tauri/pyembed/python/lib)"

          echo "PYO3_PYTHON=$PYO3_PYTHON" >> $GITHUB_ENV
          echo "RUSTFLAGS=$RUSTFLAGS" >> $GITHUB_ENV

      - name: Build and bundle the app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: v__VERSION__ # the action automatically replaces \_\_VERSION\_\_ with the app version.
          releaseName: "Local Translate v__VERSION__"
          releaseBody: "See the assets to download this version and install."
          releaseDraft: false
          includeDebug: false
          includeUpdaterJson: true
          args: '--target ${{ matrix.target }} --config src-tauri/tauri.bundle.json --verbose'

  update-homebrew-cask:
    needs: [bump-version, publish-tauri]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Download DMG assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release download "v${{ needs.bump-version.outputs.version }}" \
            --repo "${{ github.repository }}" \
            --pattern "*_aarch64.dmg" \
            --dir dmgs

      - name: Compute SHA256 hashes
        id: sha
        run: |
          VERSION="${{ needs.bump-version.outputs.version }}"
          AARCH64_SHA=$(sha256sum "dmgs/Local.Translate_${VERSION}_aarch64.dmg" | cut -d ' ' -f1)
          echo "aarch64=$AARCH64_SHA" >> "$GITHUB_OUTPUT"

      - name: Generate cask formula
        env:
          VERSION: ${{ needs.bump-version.outputs.version }}
          AARCH64_SHA: ${{ steps.sha.outputs.aarch64 }}
        run: |
          cat > local-translate.rb << 'RUBY'
          cask "local-translate" do
            version "PLACEHOLDER_VERSION"

            url "https://github.com/fcjr/local-translate/releases/download/v#{version}/Local.Translate_#{version}_aarch64.dmg"
            sha256 "PLACEHOLDER_AARCH64_SHA"

            name "Local Translate"
            desc "Privacy-first, offline desktop translation app"
            homepage "https://github.com/fcjr/local-translate"

            depends_on macos: ">= :ventura"
            depends_on arch: :arm64

            app "Local Translate.app"

            livecheck do
              url :url
              strategy :github_latest
              regex(/^v?(\d+(?:\.\d+)+)$/i)
            end

            zap trash: [
              "~/Library/Application Support/com.leftshift.local-translate.app",
              "~/.cache/local-translate",
            ]
          end
          RUBY

          sed -i "s/PLACEHOLDER_VERSION/$VERSION/" local-translate.rb
          sed -i "s/PLACEHOLDER_AARCH64_SHA/$AARCH64_SHA/" local-translate.rb

      - name: Push cask to Homebrew tap
        env:
          GH_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          CONTENT=$(base64 -w 0 local-translate.rb)

          # Check if the file already exists to get its SHA (needed for updates)
          EXISTING_SHA=$(gh api \
            "repos/fcjr/homebrew-fcjr/contents/Casks/local-translate.rb" \
            --jq '.sha' 2>/dev/null || echo "")

          JSON_PAYLOAD=$(jq -n \
            --arg message "Update local-translate to ${{ needs.bump-version.outputs.version }}" \
            --arg content "$CONTENT" \
            --arg sha "$EXISTING_SHA" \
            'if $sha == "" then {message: $message, content: $content} else {message: $message, content: $content, sha: $sha} end')

          gh api -X PUT \
            "repos/fcjr/homebrew-fcjr/contents/Casks/local-translate.rb" \
            --input - <<< "$JSON_PAYLOAD"
